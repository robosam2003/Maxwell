//
// Created by robos on 07/09/2023.
//

#ifndef MAXWELL_CONFIG_H
#define MAXWELL_CONFIG_H
#include "Arduino.h"

#define HARDWARE_V1_0
#define SENSE_CONVERSION_FACTOR  ((3.3 / 4096) * 19.0)
#define CURRENT_SENSE_CONVERSION_FACTOR ((3.3 / 4096))
#define POLE_PAIRS_6374 7 // 14 poles = 7 pole pairs

#define MAX_PWM_PULSE_US 100000


#define _2_SQRT3 1.15470053838f
#define _SQRT3 1.73205080757f
#define _1_SQRT3 0.57735026919f
#define _SQRT3_2 0.86602540378f
#define _SQRT2 1.41421356237f
#define _120_D2R 2.09439510239f
#define _PI 3.14159265359f
#define _PI_2 1.57079632679f
#define _PI_3 1.0471975512f
#define _2PI 6.28318530718f
#define _3PI_2 4.71238898038f
#define _PI_6 0.52359877559f
#define _RPM_TO_RADS 0.10471975512f



struct float_frame {
  String name;
  std::vector<double> values;
};

struct string_frame {
  String name;
  std::vector<String> values;
};

inline int calcuate_checksum(String text) {
  // calculate checksum
  int checksum = 0;
  for (int i = 0; i < text.length(); i++) {
    checksum += text[i]; // add the ASCII value of each character
  }
  checksum = checksum % 256;
  return checksum;
}

inline void send_frame(float_frame& frame) {
  String frame_string = "";
  frame_string += frame.name; frame_string += "/";
  for (auto value : frame.values) {
    frame_string += String(value); frame_string += "/";
  }

  int checksum = calcuate_checksum(frame_string);
  frame_string += "|";
  frame_string += String(checksum);
  Serial.println(frame_string);
}

inline void send_name_frame(string_frame& frame) {

}

inline void send_frame(string_frame& frame, bool nameset=false) {
  String frame_string = "";
  if (nameset) frame_string += "NAMESET";

  frame_string += frame.name; frame_string += "/";
  for (auto value : frame.values) {
    frame_string += value; frame_string += "/";
  }

  int checksum = calcuate_checksum(frame_string);
  frame_string += "|";
  frame_string += String(checksum);
  Serial.println(frame_string);
}


// // function approximating the sine calculation by using fixed size array
// // uses a 65 element lookup table and interpolation
// // thanks to @dekutree for his work on optimizing this
// __attribute__((weak)) float _sin(float a){
//     // 16bit integer array for sine lookup. interpolation is used for better precision
//     // 16 bit precision on sine value, 8 bit fractional value for interpolation, 6bit LUT size
//     // resulting precision compared to stdlib sine is 0.00006480 (RMS difference in range -PI,PI for 3217 steps)
//     static uint16_t sine_array[65] = {0,804,1608,2411,3212,4011,4808,5602,6393,7180,7962,8740,9512,10279,11039,11793,12540,13279,14010,14733,15447,16151,16846,17531,18205,18868,19520,20160,20788,21403,22006,22595,23170,23732,24279,24812,25330,25833,26320,26791,27246,27684,28106,28511,28899,29269,29622,29957,30274,30572,30853,31114,31357,31581,31786,31972,32138,32286,32413,32522,32610,32679,32729,32758,32768};
//     int32_t t1, t2;
//     unsigned int i = (unsigned int)(a * (64*4*256.0f/_2PI));
//     int frac = i & 0xff;
//     i = (i >> 8) & 0xff;
//     if (i < 64) {
//         t1 = (int32_t)sine_array[i]; t2 = (int32_t)sine_array[i+1];
//     }
//     else if(i < 128) {
//         t1 = (int32_t)sine_array[128 - i]; t2 = (int32_t)sine_array[127 - i];
//     }
//     else if(i < 192) {
//         t1 = -(int32_t)sine_array[-128 + i]; t2 = -(int32_t)sine_array[-127 + i];
//     }
//     else {
//         t1 = -(int32_t)sine_array[256 - i]; t2 = -(int32_t)sine_array[255 - i];
//     }
//     return (1.0f/32768.0f) * (t1 + (((t2 - t1) * frac) >> 8));
// }












static float sin_table[512] = {0.0000000000000000, 0.0030739605733556, 0.0061478921000710, 0.0092217655337805, 0.0122955518286674, 0.0153692219397383, 0.0184427468230976, 0.0215160974362222,
0.0245892447382355, 0.0276621596901822, 0.0307348132553025, 0.0338071763993063, 0.0368792200906482, 0.0399509153008010, 0.0430222330045305, 0.0460931441801697,
0.0491636198098930, 0.0522336308799904, 0.0553031483811414, 0.0583721433086898, 0.0614405866629169, 0.0645084494493163, 0.0675757026788672, 0.0706423173683090,
0.0737082645404146, 0.0767735152242645, 0.0798380404555204, 0.0829018112766993, 0.0859647987374465, 0.0890269738948095, 0.0920883078135117, 0.0951487715662252,
0.0982083362338450, 0.1012669729057614, 0.1043246526801336, 0.1073813466641630, 0.1104370259743658, 0.1134916617368462, 0.1165452250875691, 0.1195976871726329,
0.1226490191485420, 0.1256991921824799, 0.1287481774525808, 0.1317959461482026, 0.1348424694701988, 0.1378877186311911, 0.1409316648558405, 0.1439742793811203,
0.1470155334565870, 0.1500553983446527, 0.1530938453208558, 0.1561308456741335, 0.1591663707070920, 0.1622003917362785, 0.1652328800924518, 0.1682638071208532,
0.1712931441814776, 0.1743208626493438, 0.1773469339147651, 0.1803713293836197, 0.1833940204776208, 0.1864149786345866, 0.1894341753087103, 0.1924515819708299,
0.1954671701086976, 0.1984809112272493, 0.2014927768488739, 0.2045027385136822, 0.2075107677797762, 0.2105168362235175, 0.2135209154397960, 0.2165229770422984,
0.2195229926637764, 0.2225209339563144, 0.2255167725915980, 0.2285104802611811, 0.2315020286767539, 0.2344913895704097, 0.2374785346949124, 0.2404634358239632,
0.2434460647524675, 0.2464263932968010, 0.2494043932950767, 0.2523800366074104, 0.2553532951161870, 0.2583241407263258, 0.2612925453655463, 0.2642584809846334,
0.2672219195577024, 0.2701828330824637, 0.2731411935804876, 0.2760969730974688, 0.2790501437034901, 0.2820006774932866, 0.2849485465865094, 0.2878937231279889,
0.2908361792879984, 0.2937758872625165, 0.2967128192734902, 0.2996469475690973, 0.3025782444240085, 0.3055066821396498, 0.3084322330444635, 0.3113548694941706,
0.3142745638720312, 0.3171912885891060, 0.3201050160845165, 0.3230157188257060, 0.3259233693086993, 0.3288279400583629, 0.3317294036286644, 0.3346277326029319,
0.3375228995941133, 0.3404148772450346, 0.3433036382286588, 0.3461891552483443, 0.3490714010381020, 0.3519503483628540, 0.3548259700186902, 0.3576982388331255,
0.3605671276653568, 0.3634326094065193, 0.3662946569799427, 0.3691532433414071, 0.3720083414793982, 0.3748599244153631, 0.3777079652039648, 0.3805524369333370,
0.3833933127253383, 0.3862305657358064, 0.3890641691548113, 0.3918940962069093, 0.3947203201513952, 0.3975428142825558, 0.4003615519299217, 0.4031765064585194,
0.4059876512691231, 0.4087949597985061, 0.4115984055196916, 0.4143979619422036, 0.4171936026123168, 0.4199853011133072, 0.4227730310657010, 0.4255567661275246,
0.4283364799945529, 0.4311121464005582, 0.4338837391175581, 0.4366512319560639, 0.4394145987653273, 0.4421738134335882, 0.4449288498883210, 0.4476796820964812,
0.4504262840647512, 0.4531686298397861, 0.4559066935084587, 0.4586404491981049, 0.4613698710767673, 0.4640949333534402, 0.4668156102783126, 0.4695318761430120,
0.4722437052808471, 0.4749510720670502, 0.4776539509190199, 0.4803523162965619, 0.4830461427021314, 0.4857354046810731, 0.4884200768218623, 0.4911001337563450,
0.4937755501599772, 0.4964463007520647, 0.4991123602960015, 0.5017737035995087, 0.5044303055148723, 0.5070821409391809, 0.5097291848145631, 0.5123714121284235,
0.5150087979136803, 0.5176413172490000, 0.5202689452590338, 0.5228916571146521, 0.5255094280331793, 0.5281222332786283, 0.5307300481619334, 0.5333328480411842,
0.5359306083218588, 0.5385233044570553, 0.5411109119477246, 0.5436934063429010, 0.5462707632399342, 0.5488429582847193, 0.5514099671719267, 0.5539717656452329,
0.5565283294975480, 0.5590796345712464, 0.5616256567583930, 0.5641663720009731, 0.5667017562911176, 0.5692317856713317, 0.5717564362347204, 0.5742756841252140,
0.5767895055377950, 0.5792978767187210, 0.5818007739657510, 0.5842981736283684, 0.5867900521080045, 0.5892763858582618, 0.5917571513851364, 0.5942323252472400,
0.5967018840560212, 0.5991658044759870, 0.6016240632249226, 0.6040766370741117, 0.6065235028485568, 0.6089646374271966, 0.6114000177431259, 0.6138296207838128,
0.6162534235913163, 0.6186714032625034, 0.6210835369492653, 0.6234898018587335, 0.6258901752534950, 0.6282846344518074, 0.6306731568278127, 0.6330557198117519,
0.6354323008901774, 0.6378028776061665, 0.6401674275595332, 0.6425259284070395, 0.6448783578626076, 0.6472246936975293, 0.6495649137406770, 0.6518989958787125,
0.6542269180562963, 0.6565486582762959, 0.6588641945999939, 0.6611735051472949, 0.6634765680969326, 0.6657733616866754, 0.6680638642135335, 0.6703480540339617,
0.6726259095640662, 0.6748974092798069, 0.6771625317172018, 0.6794212554725292, 0.6816735592025301, 0.6839194216246106, 0.6861588215170413, 0.6883917377191600,
0.6906181491315697, 0.6928380347163393, 0.6950513734972019, 0.6972581445597525, 0.6994583270516471, 0.7016519001827978, 0.7038388432255709, 0.7060191355149817,
0.7081927564488907, 0.7103596854881971, 0.7125199021570339, 0.7146733860429609, 0.7168201167971578, 0.7189600741346164, 0.7210932378343319, 0.7232195877394948,
0.7253391037576805, 0.7274517658610397, 0.7295575540864875, 0.7316564485358921, 0.7337484293762626, 0.7358334768399366, 0.7379115712247672, 0.7399826928943086,
0.7420468222780019, 0.7441039398713606, 0.7461540262361539, 0.7481970620005911, 0.7502330278595043, 0.7522619045745312, 0.7542836729742965, 0.7562983139545929,
0.7583058084785624, 0.7603061375768755, 0.7622992823479104, 0.7642852239579322, 0.7662639436412703, 0.7682354227004961, 0.7701996425065992, 0.7721565844991642,
0.7741062301865452, 0.7760485611460414, 0.7779835590240701, 0.7799112055363413, 0.7818314824680298, 0.7837443716739473, 0.7856498550787143, 0.7875479146769303,
0.7894385325333445, 0.7913216907830248, 0.7931973716315270, 0.7950655573550628, 0.7969262303006670, 0.7987793728863649, 0.8006249676013378, 0.8024629970060890,
0.8042934437326082, 0.8061162904845358, 0.8079315200373265, 0.8097391152384114, 0.8115390590073610, 0.8133313343360459, 0.8151159242887980, 0.8168928120025699,
0.8186619806870948, 0.8204234136250452, 0.8221770941721904, 0.8239230057575542, 0.8256611318835709, 0.8273914561262423, 0.8291139621352914, 0.8308286336343184,
0.8325354544209532, 0.8342344083670096, 0.8359254794186368, 0.8376086515964717, 0.8392839089957896, 0.8409512357866548, 0.8426106162140693, 0.8442620345981230,
0.8459054753341410, 0.8475409228928310, 0.8491683618204308, 0.8507877767388531, 0.8523991523458320, 0.8540024734150672, 0.8555977247963672, 0.8571848914157937,
0.8587639582758029, 0.8603349104553882, 0.8618977331102202, 0.8634524114727877, 0.8649989308525372, 0.8665372766360108, 0.8680674342869859, 0.8695893893466109,
0.8711031274335433, 0.8726086342440842, 0.8741058955523147, 0.8755948972102293, 0.8770756251478704, 0.8785480653734606, 0.8800122039735355, 0.8814680271130748,
0.8829155210356329, 0.8843546720634693, 0.8857854665976779, 0.8872078911183146, 0.8886219321845260, 0.8900275764346766, 0.8914248105864739, 0.8928136214370948,
0.8941939958633101, 0.8955659208216087, 0.8969293833483204, 0.8982843705597389, 0.8996308696522434, 0.9009688679024191, 0.9022983526671783, 0.9036193113838791,
0.9049317315704446, 0.9062356008254805, 0.9075309068283925, 0.9088176373395029, 0.9100957802001655, 0.9113653233328813, 0.9126262547414126, 0.9138785625108956,
0.9151222348079536, 0.9163572598808090, 0.9175836260593937, 0.9188013217554598, 0.9200103354626891, 0.9212106557568015, 0.9224022712956635, 0.9235851708193948,
0.9247593431504753, 0.9259247771938498, 0.9270814619370340, 0.9282293864502176, 0.9293685398863680, 0.9304989114813332, 0.9316204905539424, 0.9327332665061080,
0.9338372288229252, 0.9349323670727715, 0.9360186709074053, 0.9370961300620638, 0.9381647343555596, 0.9392244736903772, 0.9402753380527684, 0.9413173175128471,
0.9423504022246824, 0.9433745824263926, 0.9443898484402369, 0.9453961906727069, 0.9463935996146172, 0.9473820658411956, 0.9483615800121715, 0.9493321328718650,
0.9502937152492738, 0.9512463180581597, 0.9521899322971352, 0.9531245490497476, 0.9540501594845643, 0.9549667548552552, 0.9558743265006761, 0.9567728658449502,
0.9576623643975494, 0.9585428137533742, 0.9594142055928333, 0.9602765316819221, 0.9611297838723007, 0.9619739541013710, 0.9628090343923521, 0.9636350168543569,
0.9644518936824656, 0.9652596571578002, 0.9660582996475965, 0.9668478136052775, 0.9676281915705237, 0.9683994261693439, 0.9691615101141451, 0.9699144362038011,
0.9706581973237205, 0.9713927864459141, 0.9721181966290613, 0.9728344210185756, 0.9735414528466696, 0.9742392854324184, 0.9749279121818236, 0.9756073265878744,
0.9762775222306105, 0.9769384927771817, 0.9775902319819080, 0.9782327336863389, 0.9788659918193116, 0.9794900003970076, 0.9801047535230103, 0.9807102453883600,
0.9813064702716093, 0.9818934225388766, 0.9824710966438995, 0.9830394871280879, 0.9835985886205743, 0.9841483958382657, 0.9846889035858932, 0.9852201067560606,
0.9857420003292932, 0.9862545793740850, 0.9867578390469456, 0.9872517745924454, 0.9877363813432609, 0.9882116547202192, 0.9886775902323404, 0.9891341834768805,
0.9895814301393732, 0.9900193259936703, 0.9904478669019816, 0.9908670488149146, 0.9912768677715121, 0.9916773198992900, 0.9920684014142734, 0.9924501086210331,
0.9928224379127202, 0.9931853857710996, 0.9935389487665842, 0.9938831235582669, 0.9942179068939520, 0.9945432956101858, 0.9948592866322874, 0.9951658769743766,
0.9954630637394027, 0.9957508441191721, 0.9960292153943743, 0.9962981749346078, 0.9965577201984051, 0.9968078487332565, 0.9970485581756335, 0.9972798462510111,
0.9975017107738889, 0.9977141496478124, 0.9979171608653922, 0.9981107425083233, 0.9982948927474035, 0.9984696098425497, 0.9986348921428155, 0.9987907380864063,
0.9989371462006937, 0.9990741151022300, 0.9992016434967610, 0.9993197301792383, 0.9994283740338304, 0.9995275740339341, 0.9996173292421829, 0.9996976388104571,
0.9997685019798909, 0.9998299180808800, 0.9998818865330880, 0.9999244068454518, 0.9999574786161860, 0.9999811015327870, 0.9999952753720357, 1.0000000000000000};





__attribute__((weak)) float _sin(float angle) {
    angle = angle - floor(angle / _2PI) * _2PI; // normalize angle to [0, 2*PI]

    int i = static_cast<int>((angle / _2PI)*512*4);
    i %= 2048;
    float ret = 0;
    if (i <= 511) {
        ret = sin_table[i];
    }
    else if (i <= 1023) {
        ret = sin_table[1023-i];
    }
    else if (i <= 1535) {
        ret = -sin_table[i - 1024];
    }
    else {
        ret = -sin_table[2047-i];
    }
    return ret;
}

__attribute__((weak)) float _cos(float angle) {
  return _sin(_PI_2 - angle);
}


// function finds the appropriate timer source trigger for the master/slave timer combination
// returns -1 if no trigger source is found
// currently supports the master timers to be from TIM1 to TIM4 and TIM8
inline int _getInternalSourceTrigger(HardwareTimer* master, HardwareTimer* slave) {
  // put master and slave in temp variables to avoid arrows
  TIM_TypeDef *TIM_master = master->getHandle()->Instance;
  TIM_TypeDef *TIM_slave = slave->getHandle()->Instance;
  #if defined(TIM1) && defined(LL_TIM_TS_ITR0)
    if (TIM_master == TIM1){
      #if defined(TIM2)
      if(TIM_slave == TIM2) return LL_TIM_TS_ITR0;
      #endif
      #if defined(TIM3)
      else if(TIM_slave == TIM3) return LL_TIM_TS_ITR0;
      #endif
      #if defined(TIM4)
      else if(TIM_slave == TIM4) return LL_TIM_TS_ITR0;
      #endif
      #if defined(TIM8)
      else if(TIM_slave == TIM8) return LL_TIM_TS_ITR0;
      #endif
    }
  #endif
  #if defined(TIM2) &&  defined(LL_TIM_TS_ITR1)
    else if (TIM_master == TIM2){
      #if defined(TIM1)
      if(TIM_slave == TIM1) return LL_TIM_TS_ITR1;
      #endif
      #if defined(TIM3)
      else if(TIM_slave == TIM3) return LL_TIM_TS_ITR1;
      #endif
      #if defined(TIM4)
      else if(TIM_slave == TIM4) return LL_TIM_TS_ITR1;
      #endif
      #if defined(TIM8)
      else if(TIM_slave == TIM8) return LL_TIM_TS_ITR1;
      #endif
      #if defined(TIM5)
      else if(TIM_slave == TIM5) return LL_TIM_TS_ITR0;
      #endif
    }
  #endif
  #if defined(TIM3) &&  defined(LL_TIM_TS_ITR2)
    else if (TIM_master == TIM3){
      #if defined(TIM1)
      if(TIM_slave == TIM1) return LL_TIM_TS_ITR2;
      #endif
      #if defined(TIM2)
      else if(TIM_slave == TIM2) return LL_TIM_TS_ITR2;
      #endif
      #if defined(TIM4)
      else if(TIM_slave == TIM4) return LL_TIM_TS_ITR2;
      #endif
      #if defined(TIM5)
      else if(TIM_slave == TIM5) return LL_TIM_TS_ITR1;
      #endif
    }
  #endif
  #if defined(TIM4) &&  defined(LL_TIM_TS_ITR3)
    else if (TIM_master == TIM4){
      #if defined(TIM1)
      if(TIM_slave == TIM1) return LL_TIM_TS_ITR3;
      #endif
      #if defined(TIM2)
      else if(TIM_slave == TIM2) return LL_TIM_TS_ITR3;
      #endif
      #if defined(TIM3)
      else if(TIM_slave == TIM3) return LL_TIM_TS_ITR3;
      #endif
      #if defined(TIM8)
      else if(TIM_slave == TIM8) return LL_TIM_TS_ITR2;
      #endif
      #if defined(TIM5)
      else if(TIM_slave == TIM5) return LL_TIM_TS_ITR1;
      #endif
    }
  #endif
  #if defined(TIM5)
    else if (TIM_master == TIM5){
      #if !defined(STM32L4xx) // only difference between F4,F1 and L4
      #if defined(TIM1)
      if(TIM_slave == TIM1) return LL_TIM_TS_ITR0;
      #endif
      #if defined(TIM3)
      else if(TIM_slave == TIM3) return LL_TIM_TS_ITR2;
      #endif
      #endif
      #if defined(TIM8)
      if(TIM_slave == TIM8) return LL_TIM_TS_ITR3;
      #endif
    }
  #endif
  #if defined(TIM8)
    else if (TIM_master == TIM8){
      #if defined(TIM2)
      if(TIM_slave==TIM2) return LL_TIM_TS_ITR1;
      #endif
      #if defined(TIM4)
      else if(TIM_slave == TIM4) return LL_TIM_TS_ITR3;
      #endif
      #if defined(TIM5)
      else if(TIM_slave == TIM5) return LL_TIM_TS_ITR3;
      #endif
    }
  #endif
  return -1; // combination not supported
}

















// ============ ARCHIVE ============
//extern "C" void SystemClock_Config(void)
//{
//    RCC_OscInitTypeDef RCC_OscInitStruct = {0};
//    RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
//
//    /** Configure the main internal regulator output voltage
//    */
//    __HAL_RCC_PWR_CLK_ENABLE();
//    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
//
//    /** Initializes the RCC Oscillators according to the specified parameters
//    * in the RCC_OscInitTypeDef structure.
//    */
//    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
//    RCC_OscInitStruct.HSEState = RCC_HSE_ON;
//    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
//    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
//    RCC_OscInitStruct.PLL.PLLM = 8;
//    RCC_OscInitStruct.PLL.PLLN = 72;
//    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
//    RCC_OscInitStruct.PLL.PLLQ = 3;
//
//    RCC_PeriphCLKInitTypeDef PeriphClkInit = {};
//    if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
//    {
//        Error_Handler();
//    }
//
//    /** Initializes the CPU, AHB and APB buses clocks
//    */
//    RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
//                                  |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
//    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
//    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
//    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
//    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
//
//    if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
//    {
//        Error_Handler();
//    }
//}

//void JumpToBootloader(void) {
//    void (*SysMemBootJump)(void);
//
//    /**
//     * Step: Set system memory address.
//     *
//     *       For STM32F429, system memory is on 0x1FFF 0000
//     *       For other families, check AN2606 document table 110 with descriptions of memory addresses
//     */
//    volatile uint32_t addr = 0x1FFF0000;
//
//    /**
//     * Step: Disable RCC, set it to default (after reset) settings
//     *       Internal clock, no PLL, etc.
//     */
//#if defined(USE_HAL_DRIVER)
//    HAL_RCC_DeInit();
//#endif /* defined(USE_HAL_DRIVER) */
//#if defined(USE_STDPERIPH_DRIVER)
//    RCC_DeInit();
//#endif /* defined(USE_STDPERIPH_DRIVER) */
//
//    /**
//     * Step: Disable systick timer and reset it to default values
//     */
//    SysTick->CTRL = 0;
//    SysTick->LOAD = 0;
//    SysTick->VAL = 0;
//
//    /**
//     * Step: Disable all interrupts
//     */
//    __disable_irq();
//
//    /**
//     * Step: Remap system memory to address 0x0000 0000 in address space
//     *       For each family registers may be different.
//     *       Check reference manual for each family.
//     *
//     *       For STM32F4xx, MEMRMP register in SYSCFG is used (bits[1:0])
//     *       For STM32F0xx, CFGR1 register in SYSCFG is used (bits[1:0])
//     *       For others, check family reference manual
//     */
//    //Remap by hand... {
//#if defined(STM32F4)
//    SYSCFG->MEMRMP = 0x01;
//#endif
//#if defined(STM32F0)
//    SYSCFG->CFGR1 = 0x01;
//#endif
//    //} ...or if you use HAL drivers
//    //__HAL_SYSCFG_REMAPMEMORY_SYSTEMFLASH();    //Call HAL macro to do this for you
//
//    /**
//     * Step: Set jump memory location for system memory
//     *       Use address with 4 bytes offset which specifies jump location where program starts
//     */
//    SysMemBootJump = (void (*)(void)) (*((uint32_t *)(addr + 4)));
//
//    /**
//     * Step: Set main stack pointer.
//     *       This step must be done last otherwise local variables in this function
//     *       don't have proper value since stack pointer is located on different position
//     *
//     *       Set direct address location which specifies stack pointer in SRAM location
//     */
//    __set_MSP(*(uint32_t *)addr);
//
//    /**
//     * Step: Actually call our function to jump to set location
//     *       This will start system memory execution
//     */
//    SysMemBootJump();
//
//    /**
//     * Step: Connect USB<->UART converter to dedicated USART pins and test
//     *       and test with bootloader works with STM32 Flash Loader Demonstrator software
//     */
//}
//
//
//
//#define BOOTLOADER_MAGIC_NUMBER "4242"

#endif //MAXWELL_CONFIG_H
